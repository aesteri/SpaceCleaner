#include "main.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h> 
#include <stdbool.h>

#include <time.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/garbage.h"
#include "images/startscreen.h"
#include "images/hot_girl.h"
#include "images/space.h"
#include "images/poopimg.h"
#include "images/elon.h"
#include "images/trump.h"
#include "images/pick.h"
#include "images/trumpPick.h"
#include "images/elonPick.h"

#include "images/win.h"
#include "images/pressZ.h"
#include "images/anim1.h"
#include "images/anim2.h"
#include "images/anim3.h"
/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  READING,
  USERNAME,
  SCENE1,
};
const u16 *anims[] = { anim1, anim2, anim3 };
int animCounter = 0;
player P;
poop totalPoopInAir[4];
int main(void) {
  srand(time(NULL));
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE; // What is BG2???
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;
  
  // Initalize player
 
  
  // int affectionLevel = 0;

  int counter = 0;
  // Load initial application state
  enum gba_state state = START;
  char *firstScene[] = {
    "Hey I'm the narrator",
    "Who are you?"
  };
  spawnPoop();
  enum gba_state next_state;
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    if (KEY_DOWN(BUTTON_SELECT, currentButtons))
    {
      state = START;
      // reset player pos
      counter = 0;
      P.col = 50;
      P.prevcol = 50; 
      P.row = 50;
      P.prevrow = 50;
      P.totalPoop = 0;

      // 
    }
    switch (state) {
      case START:
        // state = ?
        state = START;

        waitForVBlank();

        drawFullScreenImageDMA(startscreen);
        drawImageDMA(110, 100, 50, 50, anims[animCounter]);
        
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons))
        {
          state = SCENE1;
        }
        animCounter++;
        if (animCounter >= 3)
        {
          animCounter = 0;
        }
        
        break;
      case SCENE1:
        // state = ?
        state = SCENE1;
        waitForVBlank();

        if (counter > 1)
        {
          state = USERNAME; 
          drawFullScreenImageDMA(pick);
          break;
        }
        
        reset(pressZ);

        animateString(50, 50, firstScene[counter], YELLOW);

        next_state = SCENE1;
        
        state = READING;
        break;
      case PLAY:
        state = PLAY;
        
        waitForVBlank();

        
        
        char buffer[50];  // Buffer to hold the formatted string
        // Format the string with the total poop count
        sprintf(buffer, "Total poop cleaned: %d", P.totalPoop);
        // Now pass the formatted string to drawString
        
        drawString(5, 5, buffer, YELLOW);
       

        for (size_t i = 0; i < 4; i++)
        {
          undrawImageDMA(totalPoopInAir[i].prevrow, totalPoopInAir[i].prevcol, totalPoopInAir[i].width, totalPoopInAir[i].height, space);
          drawImageDMA(totalPoopInAir[i].row, totalPoopInAir[i].col, totalPoopInAir[i].width, totalPoopInAir[i].height, totalPoopInAir[i].image);
        }

        undrawImageDMA(P.prevcol, P.prevrow, P.width, P.height, space);
        drawImageDMA(P.col, P.row, P.width, P.height, P.image);
        
        
        

        int step = 2;
        P.prevcol = P.col;
        P.prevrow = P.row;
        if (KEY_DOWN(BUTTON_UP, currentButtons))
        {
          P.col -= step;
        } else if (KEY_DOWN(BUTTON_DOWN, currentButtons))
        {
          P.col += step;
        } else if (KEY_DOWN(BUTTON_LEFT, currentButtons))
        {
          P.row -= step;
        } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons))
        {
          P.row += step;
        }
        movePoop(1);
        checkBorder();
        
        if (P.totalPoop >= 10)
        {
          state = WIN;
        }
        
        break;
      case WIN:

        // state = ?
        state = WIN;

        waitForVBlank();

        drawFullScreenImageDMA(win);
        
        break;
      case USERNAME:
        state = USERNAME;
        waitForVBlank();
        
        if (KEY_DOWN(BUTTON_L, currentButtons))
        {
          drawFullScreenImageDMA(trumpPick);
          strcpy(P.name, "Trump");
          P.image = trump;
          P.height = TRUMP_HEIGHT;
          P.width = TRUMP_WIDTH;
        }
        if (KEY_DOWN(BUTTON_A, currentButtons))
        {
          drawFullScreenImageDMA(elonPick);
          strcpy(P.name, "Musk");
          P.image = elon;// change
          P.height = ELON_HEIGHT;
          P.width = ELON_WIDTH;
        }
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons))
        {
          if (P.name == NULL)
          {
            state = USERNAME;
            break;
          }
          
          reset(space);

          char buffer[50];  // Buffer to hold the formatted string
          // Format the string with the total poop count
          sprintf(buffer, "Congrats! You are %s!", P.name);
          // Now pass the formatted string to drawString
       
          animateString(50, 50, buffer, YELLOW);
          //add next state for WIN
          next_state = PLAY;
          
  
          state = READING;
        }
        break;
      case READING:
        state = READING;
        
        if (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons))
        {
          counter++;
          state = next_state;
          reset(space);
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}

void animateString(int row, int col, char *str, u16 color){
  for (size_t i = 0; i < strlen(str); i++) {
    waitForVBlank();
    drawChar(row, col + i * 6, str[i], color);
  }
}

void reset(const u16 *image) {
  drawFullScreenImageDMA(image);
}

void spawnPoop(void) {
  for (size_t i = 0; i < 4; i++)
  {
    poop X;
    X.width = POOPIMG_WIDTH;
    X.height = POOPIMG_HEIGHT;

    int poop_col = rand() % (WIDTH - X.width);
    int poop_row = rand() % (HEIGHT - X.height) + 20;
    int poop_direction = rand() % 8;

    
    X.direction = poop_direction;
    X.row = poop_row;
    X.col = poop_col;
    X.prevcol = poop_row;
    X.prevrow = poop_col;
    X.image = poopimg;
    
    totalPoopInAir[i] = X;
  }
}

void movePoop(int step) {
  for (size_t i = 0; i < 4; i++) {
    totalPoopInAir[i].prevcol = totalPoopInAir[i].col;
    totalPoopInAir[i].prevrow = totalPoopInAir[i].row;

    // Save current values
    int newRow = totalPoopInAir[i].row;
    int newCol = totalPoopInAir[i].col;

    switch(totalPoopInAir[i].direction) {
        case 0: newRow -= step; break;                  // Up
        case 1: newRow += step; break;                  // Down
        case 2: newCol -= step; break;                  // Left
        case 3: newCol += step; break;                  // Right
        case 4: newCol -= step; newRow -= step; break;  // Up-left
        case 5: newCol += step; newRow -= step; break;  // Down-left
        case 6: newCol -= step; newRow += step; break;  // Up-right
        case 7: newCol += step; newRow += step; break;  // Down-right
    }

    if (newRow < 20)
    {
      newRow = 20;
      totalPoopInAir[i].direction = rand() % 8;
    } else if (newRow + totalPoopInAir[i].height > HEIGHT)
    {
      newRow = HEIGHT - totalPoopInAir[i].height;;
      totalPoopInAir[i].direction = rand() % 8;
    } else if (newCol < 0)
    {
      newCol = 0;
      totalPoopInAir[i].direction = rand() % 8; 
    } else if (newCol + totalPoopInAir[i].width > WIDTH)
    {
      newCol = WIDTH - totalPoopInAir[i].width;;
      totalPoopInAir[i].direction = rand() % 8; 
    }

    // Commit movement
    totalPoopInAir[i].row = newRow;
    totalPoopInAir[i].col = newCol;

    if (isCollision(P, totalPoopInAir[i]))
    {
      int poop_col = rand() % (WIDTH - totalPoopInAir[i].width);
      int poop_row = rand() % (HEIGHT - totalPoopInAir[i].height)  + 20;
      int poop_direction = rand() % 8;
      undrawImageDMA(totalPoopInAir[i].row,totalPoopInAir[i].col, totalPoopInAir[i].width, totalPoopInAir[i].height, poopimg);
      totalPoopInAir[i].col = poop_col;
      totalPoopInAir[i].row = poop_row;
      totalPoopInAir[i].direction = poop_direction;
      P.totalPoop++;
      undrawImageDMA(5, 120, 20, 10, space);
    }
    
    
    
  }
}
bool isCollision(player p, poop poop) {
  // Check if the player’s rectangle and the poop’s rectangle overlap
  return (p.col < poop.row + poop.height && p.col + p.height > poop.row &&  // Check vertical overlap
          p.row < poop.col + poop.width && p.row + p.width > poop.col);   // Check horizontal overlap
}
// for the player
void checkBorder(void) {
  if (P.row < 0)
  {
    P.row = 0;
  } else if (P.row + P.width > WIDTH)
  {
    P.row = WIDTH - P.width;
  } else if (P.col < 20)
  {
    P.col = 20;
  } else if (P.col + P.height > HEIGHT)
  {
    P.col = HEIGHT - P.height;
  }
}

